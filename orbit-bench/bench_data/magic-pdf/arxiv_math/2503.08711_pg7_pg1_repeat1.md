Table 2 Running Time of BSPA for Different $p$ Values.   


<html><body><table><tr><td rowspan="2">Datasets</td><td colspan="10">P</td></tr><tr><td colspan="2">10</td><td colspan="2">30</td><td colspan="2">60</td><td colspan="2">90</td><td colspan="2">120</td></tr><tr><td></td><td>t(s)</td><td>gap</td><td>t(s)</td><td>gap</td><td>t(s)</td><td>gap</td><td>t(s)</td><td>gap</td><td>t(s)</td><td>gap</td></tr><tr><td>C</td><td>60.00</td><td>1.40</td><td>51.43</td><td>1.32</td><td>50.00</td><td>1.32</td><td>51.43</td><td>1.40</td><td>51.43</td><td>1.40</td></tr><tr><td>N</td><td>60.00</td><td>0.68</td><td>53.08</td><td>0.68</td><td>53.08</td><td>0.68</td><td>53.08</td><td>0.68</td><td>53.08</td><td>0.68</td></tr><tr><td>NT-N</td><td>132.86</td><td>2.66</td><td>75.43</td><td>2.66</td><td>60.86</td><td>2.66</td><td>60.00</td><td>2.66</td><td>60.00</td><td>2.66</td></tr><tr><td>NT-T</td><td>135.43</td><td>2.66</td><td>74.57</td><td>2.66</td><td>60.86</td><td>2.69</td><td>60.00</td><td>2.66</td><td>60.00</td><td>2.66</td></tr><tr><td>Avg</td><td>109.90</td><td>2.16</td><td>67.50</td><td>2.14</td><td>57.69</td><td>2.15</td><td>57.40</td><td>2.16</td><td>57.40</td><td>2.16</td></tr><tr><td>KR</td><td>117.50</td><td>2.70</td><td>70.00</td><td>2.70</td><td>60.00</td><td>2.70</td><td>60.00</td><td>2.70</td><td>60.00</td><td>2.70</td></tr><tr><td>BWMV</td><td>435.84</td><td>7.62</td><td>177.12</td><td>7.65</td><td>113.28</td><td>7.66</td><td>91.44</td><td>7.66</td><td>81.12</td><td>7.66</td></tr><tr><td>Avg</td><td>428.38</td><td>7.51</td><td>174.61</td><td>7.53</td><td>112.03</td><td>7.55</td><td>90.70</td><td>7.54</td><td>80.63</td><td>7.54</td></tr></table></body></html>  

Table 3 BSPA Results Under the OF and RF Scenario.   


<html><body><table><tr><td rowspan="3">Datasets</td><td colspan="4">OF</td><td colspan="4">RF</td></tr><tr><td colspan="2">BSPA(0.1,30.30.,90)</td><td colspan="2">BSPA(0.1,60.60,90)</td><td colspan="2">BSPA(0.1,30.30,90)</td><td colspan="2">BSPA(0.1,60.60.90)</td></tr><tr><td>gap</td><td>t(s)</td><td>gap</td><td>t(s)</td><td>gap</td><td>t(s)</td><td>gap</td><td>t(s)</td></tr><tr><td>C</td><td>1.40</td><td>51.43</td><td>1.32</td><td>100.00</td><td>0.79</td><td>45.7</td><td>0.75</td><td>91.43</td></tr><tr><td>N</td><td>0.68</td><td>53.08</td><td>0.67</td><td>106.15</td><td>0.72</td><td>53.1</td><td>0.60</td><td>101.54</td></tr><tr><td>NT-N</td><td>2.66</td><td>60.00</td><td>2.59</td><td>120.00</td><td>2.14</td><td>60.0</td><td>2.04</td><td>120.00</td></tr><tr><td>NT-T</td><td>2.66</td><td>60.00</td><td>2.63</td><td>120.00</td><td>2.13</td><td>60.0</td><td>2.06</td><td>120.00</td></tr><tr><td>Avg.</td><td>2.16</td><td>57.40</td><td>2.10</td><td>114.23</td><td>1.69</td><td>56.3</td><td>1.61</td><td>111.92</td></tr><tr><td>KR</td><td>2.70</td><td>60.00</td><td>2.67</td><td>120.00</td><td>1.60</td><td>60.0</td><td>1.60</td><td>120.00</td></tr><tr><td>BWMV</td><td>7.62</td><td>91.44</td><td>7.56</td><td>181.68</td><td>3.03</td><td>72.7</td><td>2.79</td><td>141.12</td></tr><tr><td>Avg.</td><td>7.51</td><td>90.70</td><td>7.44</td><td>180.23</td><td>3.00</td><td>72.4</td><td>2.76</td><td>140.63</td></tr></table></body></html>  

# 3.4. Experiment and analysis  

Table 3 presents the computational results of the algorithm under both OF and RF scenarios. In this table, the notation $\mathrm { B S P A } _ { 0 . 1 , 3 0 , 3 0 , 9 0 }$ denotes the execution of the algorithm with parameters $b = 0 . 1$ , $T _ { 1 } = 3 0 \mathrm { s }$ , $T _ { 3 } = 3 0 { \mathrm { s } }$ and $p = 9 0$ . This notation is consistently applied across other tables.  

As shown in Table 3, under both OF and RF scenarios, the proposed algorithm demonstrates a consistent reduction in the gap value across all datasets as search time increases. However, despite a twofold increase in search time, the reduction in the gap value remains marginal. Nevertheless, the gap values obtained by our algorithm across all datasets are within an acceptable range. Specifically, for the zerowaste datasets C, N, NT-N, and NT-T, the average fill length exceeds the minimum length by only $2 . 1 \%$ . For the non-zerowaste dataset KR, this deviation is merely $2 . 6 7 \%$ , while for the large-scale dataset BWMV, it remains limited to $7 . 5 7 \%$ . These results substantially outperform those of manual filling, indicating that the proposed method can be effectively applied to industrial material cutting to assist enterprises in reducing material waste during the cutting process.  

In the previous experiments, we used a platform with a 256-core processor and 120 GB of RAM to run our algorithm. However, this does not imply that the algorithm proposed in this paper is limited to such high-end configurations, as this setup was chosen solely to meet the specific requirements of the experiments. Our algorithm is capable of running on personal computers used in daily life and can even outperform the results obtained in the aforementioned experiments because personal computers usually have higher CPU frequency. Furthermore, if the algorithm is implemented using more efficient programming languages, such as C or $^ { C + + }$ , the performance of loading results within the same time limit will be further enhanced. Table 4 presents the algorithmâ€™s performance on a widely used PC with an Intel i7-13700K CPU, 16GB of RAM, and the Windows 11 operating system, using standard datasets.  

# 4. Conclusions  

This paper presents a beam search-based parallel method for solving the two-dimensional strip packing problem. Experimental results demonstrate that the proposed algorithm can find an efficient placement strategy to minimize the used length of the strip as much as possible. To facilitate future research, the code and datasets are available at https: //github.com/Yzhjdj/BSPA  